//! EventSleuth — a fast, filterable Windows Event Log viewer.
//!
//! Entry point: initialises structured logging and launches the eframe
//! application window.

// Hide the console window in release builds on Windows.
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

// Declare crate modules
mod app;
mod app_actions;
mod core;
mod export;
mod ui;
mod util;

use app::EventSleuthApp;
use util::constants;

/// Guard that holds the single-instance mutex for the lifetime of the process.
/// When dropped the OS automatically releases the mutex.
struct SingleInstanceGuard {
    _handle: windows::Win32::Foundation::HANDLE,
}

impl Drop for SingleInstanceGuard {
    fn drop(&mut self) {
        unsafe {
            let _ = windows::Win32::Foundation::CloseHandle(self._handle);
        }
    }
}

/// Attempt to acquire a named mutex. Returns `Some(guard)` if this is the
/// first instance, or `None` if another instance already holds the mutex.
fn acquire_single_instance() -> Option<SingleInstanceGuard> {
    use windows::core::w;
    use windows::Win32::Foundation::ERROR_ALREADY_EXISTS;
    use windows::Win32::System::Threading::CreateMutexW;

    let handle = unsafe {
        CreateMutexW(None, true, w!("Global\\EventSleuth_SingleInstance"))
    };

    match handle {
        Ok(h) => {
            // Check if the mutex already existed (another instance owns it)
            let last_err = unsafe { windows::Win32::Foundation::GetLastError() };
            if last_err == ERROR_ALREADY_EXISTS {
                unsafe { let _ = windows::Win32::Foundation::CloseHandle(h); }
                None
            } else {
                Some(SingleInstanceGuard { _handle: h })
            }
        }
        Err(_) => None,
    }
}

fn main() -> eframe::Result<()> {
    // Enforce single instance
    let _instance_guard = match acquire_single_instance() {
        Some(guard) => guard,
        None => {
            // Another instance is already running — show a message box and exit
            use windows::core::w;
            use windows::Win32::UI::WindowsAndMessaging::{MessageBoxW, MB_OK, MB_ICONINFORMATION};
            unsafe {
                MessageBoxW(
                    None,
                    w!("EventSleuth is already running."),
                    w!("EventSleuth"),
                    MB_OK | MB_ICONINFORMATION,
                );
            }
            return Ok(());
        }
    };

    // Initialise structured logging via tracing-subscriber.
    // Logs go to stderr; set RUST_LOG=debug for verbose output.
    tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| tracing_subscriber::EnvFilter::new("info")),
        )
        .with_target(false)
        .init();

    tracing::info!(
        "{} v{} starting",
        constants::APP_NAME,
        constants::APP_VERSION,
    );

    // Load the app icon for the titlebar
    let icon = load_app_icon();

    // Configure the native window
    let mut viewport = egui::ViewportBuilder::default()
        .with_title(format!(
            "{} v{}",
            constants::APP_NAME,
            constants::APP_VERSION
        ))
        .with_inner_size([1280.0, 800.0])
        .with_min_inner_size([800.0, 500.0])
        .with_visible(false);

    if let Some(icon) = icon {
        viewport = viewport.with_icon(icon);
    }

    let options = eframe::NativeOptions {
        viewport,
        persist_window: true,
        ..Default::default()
    };

    // Launch the application
    eframe::run_native(
        constants::APP_NAME,
        options,
        Box::new(|cc| Ok(Box::new(EventSleuthApp::new(cc)))),
    )
}

/// Load the application icon from the compile-time-embedded ICO data.
///
/// The ICO file is generated by `build.rs` and embedded via `include_bytes!`.
/// Extracts the largest image entry and decodes it to RGBA for use as
/// the window titlebar and taskbar icon.
/// Returns `None` if the icon cannot be decoded.
fn load_app_icon() -> Option<std::sync::Arc<egui::IconData>> {
    static ICO_BYTES: &[u8] = include_bytes!("../assets/icon.ico");

    // Parse the ICO header to find the largest image entry.
    // ICO format: 6-byte header, then 16-byte directory entries.
    if ICO_BYTES.len() < 6 {
        return None;
    }
    let count = u16::from_le_bytes([ICO_BYTES[4], ICO_BYTES[5]]) as usize;
    if count == 0 {
        return None;
    }

    // Find the entry with the largest dimensions
    let mut best_idx = 0usize;
    let mut best_size = 0u32;
    for i in 0..count {
        let offset = 6 + i * 16;
        if offset + 16 > ICO_BYTES.len() {
            break;
        }
        // Width/height: 0 means 256
        let w = if ICO_BYTES[offset] == 0 { 256u32 } else { ICO_BYTES[offset] as u32 };
        let h = if ICO_BYTES[offset + 1] == 0 { 256u32 } else { ICO_BYTES[offset + 1] as u32 };
        if w * h > best_size {
            best_size = w * h;
            best_idx = i;
        }
    }

    // Read the data offset and size for the best entry
    let dir_offset = 6 + best_idx * 16;
    let data_size = u32::from_le_bytes([
        ICO_BYTES[dir_offset + 8],
        ICO_BYTES[dir_offset + 9],
        ICO_BYTES[dir_offset + 10],
        ICO_BYTES[dir_offset + 11],
    ]) as usize;
    let data_offset = u32::from_le_bytes([
        ICO_BYTES[dir_offset + 12],
        ICO_BYTES[dir_offset + 13],
        ICO_BYTES[dir_offset + 14],
        ICO_BYTES[dir_offset + 15],
    ]) as usize;

    if data_offset + data_size > ICO_BYTES.len() {
        return None;
    }

    let png_data = &ICO_BYTES[data_offset..data_offset + data_size];

    // Decode the PNG into RGBA pixels
    let img = image::load_from_memory(png_data).ok()?;
    let rgba = img.to_rgba8();
    let (width, height) = (rgba.width() as u32, rgba.height() as u32);

    Some(std::sync::Arc::new(egui::IconData {
        rgba: rgba.into_raw(),
        width,
        height,
    }))
}
